# -*- coding: utf-8 -*-
"""EDA Project : World Happiness EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P-RT4J4HpVLuCyR4-uUnWnNRcTa4Tqge
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
drive.mount('/content/drive')
file_path = '//content/drive/MyDrive/world-happiness-report-2021.csv'
df = pd.read_csv(file_path)
df.head()

df.info()

print(" Missing values in each column:\n")
print(df.isnull().sum())

print("\n Number of duplicate rows:", df.duplicated().sum())

# Drop unnecessary columns
drop_cols = [
    'Standard error of ladder score', 'upperwhisker', 'lowerwhisker',
    'Ladder score in Dystopia', 'Explained by: Log GDP per capita',
    'Explained by: Social support', 'Explained by: Healthy life expectancy',
    'Explained by: Freedom to make life choices', 'Explained by: Generosity',
    'Explained by: Perceptions of corruption', 'Dystopia + residual'
]

df.drop(columns=drop_cols, inplace=True)

df.head()

df.rename(columns={
    "Country name": "Country",
    "Regional indicator": "Region",
    "Ladder score": "Happiness",
    "Logged GDP per capita": "GDP",
    "Healthy life expectancy": "Life_Expectancy",
    "Freedom to make life choices": "Freedom",
    "Perceptions of corruption": "Corruption"
}, inplace=True)

df.head()

df.describe()

import math
# List of desired numeric columns
numeric_cols = ['Happiness', 'GDP', 'Social support', 'Life_Expectancy',
                'Freedom', 'Generosity', 'Corruption']

# Keep only the columns that actually exist in the DataFrame
available_cols = [col for col in numeric_cols if col in df.columns]

# Determine grid layout (rows and columns)
num_cols = len(available_cols)
cols = 3
rows = math.ceil(num_cols / cols)

# Create subplots
fig, axes = plt.subplots(rows, cols, figsize=(16, rows * 4))
axes = axes.flatten()

# Plot histograms for each numeric column
for i, col in enumerate(available_cols):
    sns.histplot(df[col].dropna(), kde=True, color='skyblue', bins=20, ax=axes[i])
    axes[i].set_title(f'Distribution of {col}')
    axes[i].set_xlabel('')
    axes[i].set_ylabel('Frequency')

# Remove unused subplot spaces
for j in range(len(available_cols), len(axes)):
    fig.delaxes(axes[j])

# Adjust layout to prevent overlapping
plt.tight_layout()
plt.show()

# Determine grid layout
num_cols = len(available_cols)
cols = 3
rows = math.ceil(num_cols / cols)

# Create subplots
fig, axes = plt.subplots(rows, cols, figsize=(16, rows * 4))
axes = axes.flatten()

# Plot each boxplot
for i, col in enumerate(available_cols):
    sns.boxplot(x=df[col].dropna(), color='skyblue', ax=axes[i])
    axes[i].set_title(f'Box Plot of {col}')
    axes[i].set_xlabel('')

# Remove any unused subplot spaces
for j in range(len(available_cols), len(axes)):
    fig.delaxes(axes[j])

# Adjust layout
plt.tight_layout()
plt.show()

# Count the number of countries in each region
region_counts = df['Region'].value_counts()

# Create a horizontal bar chart
plt.figure(figsize=(10, 6))
sns.barplot(
    x=region_counts.values,  # Number of countries
    y=region_counts.index,   # Region names
    palette='viridis'        # Color palette
)

# Add labels and title
plt.title("Number of Countries per Region")
plt.xlabel("Number of Countries")
plt.ylabel("Region")

# Show the plot
plt.show()

features = ['GDP', 'Social support', 'Life_Expectancy',
            'Freedom', 'Generosity', 'Corruption']

fig, axes = plt.subplots(2, 3, figsize=(18, 10))
axes = axes.flatten()

for i, feature in enumerate(features):
    sns.scatterplot(x=df[feature], y=df['Happiness'], ax=axes[i], color='teal')
    axes[i].set_title(f'Happiness vs {feature}')
    axes[i].set_xlabel(feature)
    axes[i].set_ylabel('Happiness')

plt.tight_layout()
plt.show()

# Compute correlation matrix for numeric columns only
corr_matrix = df.corr(numeric_only=True)

# Create the heatmap
plt.figure(figsize=(12, 8))
sns.heatmap(
    corr_matrix,
    annot=True,          # Show correlation values
    cmap='coolwarm',     # Color scheme
    fmt=".2f",           # Format for numbers
    linewidths=0.5       # Lines between cells
)

plt.title("Correlation Matrix: All Numeric Features")
plt.show()

# Calculate the average happiness score for each region
region_avg = (
    df.groupby('Region')['Happiness']
    .mean()
    .sort_values(ascending=False)  # Sort from highest to lowest
)

# Create a horizontal bar plot of average happiness by region
plt.figure(figsize=(10, 6))
sns.barplot(
    x=region_avg.values,  # Average happiness scores
    y=region_avg.index,   # Region names
    palette='viridis'     # Color palette
)

# Add labels and title
plt.title("Average Happiness Score by Region")
plt.xlabel("Average Happiness")
plt.ylabel("Region")

# Show the plot
plt.show()

# Create a boxplot to show the distribution of Happiness by Region
plt.figure(figsize=(12, 6))
sns.boxplot(
    data=df,
    x='Region',           # Categorical variable on X-axis
    y='Happiness',        # Numeric variable on Y-axis
    palette='coolwarm'    # Color palette
)

# Rotate X-axis labels for better readability
plt.xticks(rotation=45, ha='right')

# Add title and labels
plt.title("Distribution of Happiness Scores by Region")
plt.ylabel("Happiness")
plt.xlabel("Region")

# Adjust layout to prevent label overlap
plt.tight_layout()

# Display the plot
plt.show()

# List of features to visualize by Region
features_to_plot = [
    'Happiness', 'GDP', 'Social support',
    'Life_Expectancy', 'Freedom', 'Generosity', 'Corruption'
]

# Loop through each feature and create a boxplot by Region
for col in features_to_plot:
    plt.figure(figsize=(12, 6))

    sns.boxplot(
        data=df,
        x='Region',      # Categorical variable
        y=col,           # Numeric variable to visualize
        palette='Set3'   # Color palette
    )

    # Rotate X-axis labels for better readability
    plt.xticks(rotation=45, ha='right')

    # Add title and labels
    plt.title(f"Distribution of {col} by Region")
    plt.xlabel("Region")
    plt.ylabel(col)

    # Adjust layout to prevent overlap
    plt.tight_layout()

    # Display the plot
    plt.show()

# List of features to visualize (excluding Country and Region)
features = [
    'Happiness', 'GDP', 'Social support',
    'Life_Expectancy', 'Freedom', 'Generosity', 'Corruption'
]

# Define subplot layout (number of columns and rows)
n_cols = 3
n_rows = math.ceil(len(features) / n_cols)

# Create figure and axes
fig, axes = plt.subplots(n_rows, n_cols, figsize=(18, n_rows * 4))
axes = axes.flatten()

# Loop through each feature and plot Top 10 countries
for i, col in enumerate(features):
    # Get the top 10 countries for the current feature
    top10 = df[['Country', col]].sort_values(by=col, ascending=False).head(10)

    # Create a horizontal bar chart
    sns.barplot(
        x=col,
        y='Country',
        data=top10,
        ax=axes[i],
        palette='crest'
    )

    # Set title and labels
    axes[i].set_title(f"Top 10 Countries by {col}")
    axes[i].set_xlabel(col)
    axes[i].set_ylabel("")

# Hide any unused axes if the grid is larger than the number of features
for j in range(i + 1, len(axes)):
    axes[j].axis('off')

# Adjust layout to avoid overlap
plt.tight_layout()

# Show the plots
plt.show()

# Create subplot layout for bottom 10 charts
fig, axes = plt.subplots(n_rows, n_cols, figsize=(18, n_rows * 4))
axes = axes.flatten()

# Loop through each feature and plot Bottom 10 countries
for i, col in enumerate(features):
    # Get the bottom 10 countries for the current feature
    bottom10 = (
        df[['Country', col]]
        .sort_values(by=col, ascending=True)
        .head(10)
    )

    # Create a horizontal bar chart
    sns.barplot(
        x=col,
        y='Country',
        data=bottom10,
        ax=axes[i],
        palette='rocket'  # Red-dark color palette
    )

    # Set title and labels
    axes[i].set_title(f"Bottom 10 Countries by {col}")
    axes[i].set_xlabel(col)
    axes[i].set_ylabel("")

# Hide any unused axes if the grid is larger than the number of features
for j in range(i + 1, len(axes)):
    axes[j].axis('off')

# Adjust layout for better spacing
plt.tight_layout()

# Display the plots
plt.show()